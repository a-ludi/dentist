/**
    Everything to handle insertions. `Insertion`s are generated by DENTIST
    command `process-pile-ups`. They are essentially a consensus sequence
    alongside alignment that allow precise splicing into the assembly. In
    addition, the IDs of the reads involved in the consensus are included.

    See_also: `dentist.commands.processPileUps`
    Copyright: Â© 2018 Arne Ludwig <arne.ludwig@posteo.de>
    License: Subject to the terms of the MIT license, as written in the
             included LICENSE file.
    Authors: Arne Ludwig <arne.ludwig@posteo.de>
*/
module dentist.common.insertions;

import dentist.common :
    dentistEnforce,
    ReadInterval,
    ReferenceInterval;
import dentist.common.alignments :
    AlignmentLocationSeed,
    coord_t,
    id_t,
    SeededAlignment;
import dentist.common.binio : CompressedSequence;
import dentist.common.scaffold :
    ContigNode,
    ContigPart,
    isDefault,
    isExtension,
    isGap,
    Scaffold;
import dentist.util.log;
import dentist.util.math : add;
import std.algorithm :
    among,
    canFind,
    filter,
    swap;
import std.array : array;
import std.typecons : tuple;
import vibe.data.json : toJson = serializeToJson;


/// This describes an insertion, existing contig or gap.
///
/// See_also: `Insertion`
struct InsertionInfo
{
    /// (insertions only) Consensus sequence that overlaps with the
    /// neighboring contigs.
    CompressedSequence sequence;

    /// (contigs and gaps only): the length of the object in bases.
    size_t contigLength;

    /// (insertions and contigs only): Overlaps of the sequence with the
    /// neighboring contigs. This is used to decide on the quality and exact
    /// splicing information in the `output` step.
    ///
    /// For contigs, the overlaps are transferred from incident insertions
    /// after the final scaffold graph has been constructed (see
    /// `dentist.commands.output.fixCropping`).
    SeededAlignment[] overlaps;

    /// (insertions only) Read IDs involved in creation of the consensus.
    id_t[] readIds;
}


/// This is used to collect all sub-sequences (contigs, gaps, insertions)
/// of the output.
alias OutputScaffold = Scaffold!InsertionInfo;


/// This represents a contig, gap or insertion edge with `InsertionInfo`
/// payload.
///
/// See_also: `isValidInsertion`, `isDefault`, `isOutputGap`, `isGap`,
///     `isExtension`, `hasSequence`
alias Insertion = OutputScaffold.Edge;


/// Returns true iff a sequence of `n`s should be written.
bool isOutputGap(in Insertion insertion)
{
    return !insertion.hasSequence && !insertion.isDefault;
}


/// Returns true iff insertion describes a contig (`isDefault`), gap
/// (`isOutputGap`) or insertion (`isGap`, `isExtension`, `hasSequence`).
bool isValidInsertion(in Insertion insertion)
{
    return
        insertion.isDefault ^
        insertion.isOutputGap ^
        (insertion.isGap && insertion.hasSequence) ^
        (insertion.isExtension && insertion.hasSequence);
}


/// Returns true if insertion has a non-empty sequence attached.
bool hasSequence(in Insertion insertion)
{
    return insertion.payload.sequence.length > 0;
}


/// Return the cropping position on `contig` according to `overlap`.
coord_t getCroppingPosition(string contig)(in SeededAlignment overlap) if (contig == "contigA")
{
    final switch (overlap.seed)
    {
        case AlignmentLocationSeed.front:
            return overlap.first.contigA.begin;
        case AlignmentLocationSeed.back:
            return overlap.last.contigA.end;
    }
}

/// ditto
coord_t getCroppingPosition(string contig)(in SeededAlignment overlap) if (contig == "contigB")
{
    coord_t coord;

    final switch (overlap.seed)
    {
        case AlignmentLocationSeed.front:
            coord = overlap.first.contigB.begin;
            break;
        case AlignmentLocationSeed.back:
            coord = overlap.last.contigB.end;
            break;
    }

    if (overlap.flags.complement)
        return overlap.contigB.length - coord;
    else
        return coord;
}


/// Returns information required when building the assembly.
///
/// The parameters must have a type that matches the function name, e.g.
/// `isDefault(insertion)` must be true for `getInfoForExistingContig`.
///
/// Params:
///     begin            = start node of `insertion` is required because
///         `insertion` is undirected
///     insertion        = undirected edge with `InsertionInfo` payload
///     globalComplement = current complement status in the assembly process
auto getInfoForExistingContig(in ContigNode begin, in Insertion insertion, in bool globalComplement)
{
    auto overlaps = insertion.payload.overlaps;
    auto contigId = cast(id_t) begin.contigId;
    auto contigLength = insertion.payload.contigLength;
    auto slice = ReferenceInterval(contigId, 0, contigLength);

    assert(contigLength > 0);

    switch (overlaps.length)
    {
    case 0:
        // Keep whole contig
        break;
    case 1:
        auto overlap = overlaps[0];

        final switch (overlap.seed)
        {
        case AlignmentLocationSeed.front:
            slice.begin = getCroppingPosition!"contigA"(overlap);
            break;
        case AlignmentLocationSeed.back:
            slice.end = getCroppingPosition!"contigA"(overlap);
            break;
        }
        break;
    case 2:
        assert(overlaps[0].contigA.id == overlaps[1].contigA.id);
        assert(overlaps[0].seed != overlaps[1].seed);

        if (overlaps[0].seed < overlaps[1].seed)
        {
            slice.begin = getCroppingPosition!"contigA"(overlaps[0]);
            slice.end = getCroppingPosition!"contigA"(overlaps[1]);
        }
        else
        {
            slice.begin = getCroppingPosition!"contigA"(overlaps[1]);
            slice.end = getCroppingPosition!"contigA"(overlaps[0]);
        }
        break;
    default:
        dentistEnforce(0, "too many splice sites");
    }

    assert(
        // walk contig in correct orientation
        globalComplement != (begin < insertion.target(begin)) ||
        // the contig is circular
        begin.contigId == insertion.target(begin).contigId
    );

    return tuple!(
        "contigId",
        "contigLength",
        "cropping",
        "length",
        "complement",
    )(
        contigId,
        contigLength,
        slice,
        slice.size,
        globalComplement,
    );
}

/// ditto
auto getInfoForGap(in Insertion insertion)
{
    return tuple!("length")(insertion.payload.contigLength);
}

/// ditto
auto getInfoForNewSequenceInsertion(
    in ContigNode begin,
    in Insertion insertion,
    in bool globalComplement,
)
{
    auto overlaps = insertion.payload.overlaps;
    auto firstOverlap = overlaps[0].contigA.id == begin.contigId ? overlaps[0] : overlaps[1];
    auto effectiveComplement = firstOverlap.flags.complement ^ globalComplement;

    assert(
        (insertion.isExtension && overlaps.length == 1) ^
        (insertion.isGap && overlaps.length == 2)
    );
    assert(firstOverlap.contigB.length == insertion.payload.sequence.length);

    auto slice = ReadInterval(
        firstOverlap.contigB.id,
        0,
        firstOverlap.contigB.length,
    );
    switch (overlaps.length)
    {
    case 1:
        final switch (firstOverlap.seed)
        {
        case AlignmentLocationSeed.front:
            slice.end = getCroppingPosition!"contigB"(firstOverlap);
            break;
        case AlignmentLocationSeed.back:
            slice.begin = getCroppingPosition!"contigB"(firstOverlap);
            break;
        }
        break;
    case 2:
        slice.begin = getCroppingPosition!"contigB"(overlaps[0]);
        slice.end = getCroppingPosition!"contigB"(overlaps[1]);

        if (slice.end < slice.begin)
            swap(slice.begin, slice.end);
        break;
    default:
        assert(0);
    }

    return tuple!(
        "sequence",
        "cropping",
        "length",
        "complement",
    )(
        insertion.payload.sequence,
        slice,
        slice.size,
        effectiveComplement,
    );
}
